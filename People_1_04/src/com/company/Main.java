package com.company;    // папка, в якій розміщено клас


import java.io.*;   // імпортування класів для читання/запису з/в файлу/файл
import java.util.GregorianCalendar;     // імпортування класу дати
import java.util.Scanner;   // імпортування класу для зчитування даних з консолі

public class Main {     // клас, що створився автоматично
    static int k=0;     // змінна що рахуватиме згенеровані слова
    //################################################################################################################################################################################################
    public static void main(String[] args) throws IOException {    // метод main класу Main головний, бо саме він завжди виконується при запуску програми
        GregorianCalendar g=new GregorianCalendar();    // створення дати конструктором по замовчуванню, який створить поточну дату
        int ThisYear= g.getWeekYear();  // поточний рік візьметься з методу дати
        System.out.println("Зараз "+ThisYear+" рік");   // вивід поточного року

        Human[] Hm = new Human[6];   // створення масиву людей розміру 5, клас Human видно бо він у цій же папці
        Hm[0]= new Human( 4567325,"Петренко","Іван",1969 ,667321,2353178,7313543);     // створення конкретних людей з допомогою конструктора
        Hm[1]= new Human(3250677,"Петренко","Галина",1975, 8763245,9540327,7313543);
        Hm[2]= new Human(7625054,"Kevin","Adamson",1992, 3534529, 2134533, 5432365, 4532112);   //  тут конструктору передаються діти, якох можна передати скільки завгодно, бо конструктор із змінною к-стю параметрів
        Hm[3]= new Human();     // виклик конструктора без параметрів
        Hm[4]= new Student(7313543,"Петренко","Василь",1992, 5423452, 2124422,"ЧНУ",2000, 4325087, 5680897);  // запис у масив людей студента, що можливо, бо клас Student наслідується від класу людина
        Hm[5]=new Pensioner(667321, "Петренко","Сергій",1947, 456654,983652,4498,345,4567325);

        int n=3;System.out.println("Сума всіх цілих чисел від 1 до "+n+" = "+Sum(n));   // перевірка роботи простого рекурсивного методу

        String s= null; // у змінну s запишеться слово введене з консолі
        Scanner scan = new Scanner(System.in);      // сканер із консолі
        do {    // початок блока цикла
            System.out.println("Введіть команду: ювл - ювіляри, ген - генератор слів, люд - ввести людину, друк - друк всіх людей і запис у файл, exit - вихід");
            if (scan.hasNext()) {   // якщо далі щось є,
                s = scan.next();    // то записуємо в s
                if (s.equals("ювл")) {  // якщо це слово "ювл",
                    anniversaries(ThisYear, Hm);    // то викликаємо метод, що виведе ювілярів
                }
                if (s.equals("ген")) {
                    wordGenerator();
                }
                if (s.equals("люд")) {
                    Hm=setHuman(Hm);

                }
                if (s.equals("друк")){
                    druk(Hm);
                    writeToFile(Hm);
                }
            }
        }   // кінець блока цикла
        while (!s.equals("exit") );     // цикл повторюватиметься поки не буде введено слово "exit"
        scan.close();   // закриття об'єкта сканера
        /*
         */
    }
    // дужка методу main
    //################################################################################################################################################################################################
    static void anniversaries(int ThisYear, Human[] Hm){     // статичний(для виклику не потребує створеного об'єкта) метод, друкуючий ювілярів у наступному році
        System.out.println("Ювіляри у наступному році:");
        for(int i=0;i<=2;i++){      // цикл для перебору всіх людей масиву
            if((Hm[i].getAge(ThisYear)%5==4)&(Hm[i].getAge(ThisYear)!=4))   // якщо остача від ділення віку поточної людини на 5 рівна 4 і сам вік цеї людини не 4, то
                Hm[i].print();}     // друкуємо цю людину
    }
    //################################################################################################################################################################################################
    static  Human [] setHuman(Human[] Hm) {      // статичний(для виклику не потребує створеного об'єкта) метод, що вводить ще 1 людину і повертає новий масив з цею людиною

        Scanner sc = new Scanner(System.in);
        Human temp[]=Hm;
        do {
            System.out.println("Введіть людину");
            System.out.println("Ідентифікаційний код, ім'я, прізвище, рік народження");
            String n = null;    // змінні для запису імені, прізвища і року народження
            String sn = null;
            int b = 0;
            int id = 0;
            //  створення сканера із консолі(System.in)
            if (sc.hasNextInt())   // якщо далі щось введено
                id = sc.nextInt();
            if (sc.hasNext())
                n = sc.next();
            if (n.equals("stop"))
                break;

            if (sc.hasNext())   // якщо далі щось введено
                n = sc.next();    // записуємо це в ім'я
            if (sc.hasNext())   // якщо далі щось введено
                sn = sc.next();   // записуємо це в прізвище
            if (sc.hasNextInt())    // якщо далі введено ціле число
                b = sc.nextInt();     // записуємо це в рік народження
            Human h = new Human(id, n, sn, b, -100000, -100000);    // створення людини з такими значеннями, але поки що без батьків та дітей
            temp = new Human[Hm.length + 1];   // створення масиву на 1 більшого ніж отриманого в метод
            for (int i = 0; i < Hm.length; i++)   // прохід усіх елементів переданого масиву
                temp[i] = Hm[i];  // запис їх в новий створений
            temp[Hm.length] = h;  // допис нової людини в кінець
            // передавання з методу нового масиву

        } while (true);
        return temp;
    }


    //################################################################################################################################################################################################
    static void sorting(Human[] H){     //  метод сортування масива по зростанню дати народження
        System.out.println("Відсортовано:");
        for(int j = 0; j< H.length-2; j++) {    // від першого елемента до передостаннього(бо останній вже буде відсортований)
            int min = j;  // min це номер знайденого мінімального значення, на початку вибираємо таким перший елемент масиву
            for (int i = j + 1; i < H.length; i++)     // беремо всі наступні елементи масиву
                if (H[i].birth < H[min].birth)    // і порівнюємо з мінімальним, якщо знайшли менший,
                    min = i;   // то записуємо його номер в мінімальний
            // тут опинемося після перевірки усіх елементів масиву, і в min буде номер мінімального у всьому масиві, тому його треба поміняти місцями з першим елементом
            Human temp = H[min];   // тому записуєм його в тимчасовий обєкт
            H[min] = H[j];    // у нього перший
            H[j] = temp;
        }// у перший тимчасовий, куда записували мінімальний
    }
    //################################################################################################################################################################################################
    static void druk(Human[] Hm){    // метод друку масива на консоль
        for(int j=0;j< Hm.length;j++)
            Hm[j].print();
    }
    //################################################################################################################################################################################################
    static int Sum(int i){  // простий приклад рекурсивного методу(це метод що викликає самого себе) - отримує ціле число і повертає суму цілих чисел від 1 до цього числа
        if(i==1)    // якщо отримали 1
            return  1;  // повертаємо 1
        else {  // інакше
            return i + Sum(i-1); // повертаємо отримане число + Sum(отримане число-1)(що поверне отримане число-1 + Sum(отримане число-2)...+1)
        }
    }
    //################################################################################################################################################################################################
    static void wordGenerator(){    // метод, що задає алфавіт і кількість слів для генерації і запускає метод генерації
        char[] alphabet ={'а','б','в','г','ґ','д','е','є','ж','з','и','і','ї','й','к','л','м','н','о','п','р','с','т','у','ф','х','ц','ч','ш','щ','ь','ю','я'};     // масив укр букв
        int len=4;  // кількість букв у словах, що треба згенерувати
        int[] rez =new  int[len];   // масив куди записуватимуться згенеровані номери букв з алфавіту
        wordRecursionGenerator(rez, alphabet,0);    // запуск генератора зля заданих масивів букв і номерів і для генерації першої букви
    }
    //################################################################################################################################################################################################
    static void wordRecursionGenerator(int[] rez, char[] alphabet, int poz){    // рекурсивний метод, що друкує всі можливі слова українського алфавіту з poz-ної кількості букв
        // rez - масив номерів букв, alphabet - алфавіт, poz - номер букви, що генеруємо, тобто індекс масиву rez
        if (poz>=rez.length){   // якщо номер букви став більшим ніж нам треба, то значить вже заповнили масив rez, тому треба роздрукувати згенероване слово:
            k++;    // збільшуємо к-сть згенерованих букв на 1
            System.out.print(k+": ");   // виводимо цю к-сть
            for(int j = 0; j < rez.length; j++)    // у циклі перебираємо всі згенеровані номери
                System.out.print(alphabet[rez[j]]);     // і друкуємо букву за таким згенерованим номером
            System.out.println();   // піля друку всіх букв переходимо на новий рядок
        }
        else {  // якщо номер букви НЕ став більшим ніж нам треба, то значить ще не заповнили масив rez, тому треба згенерувати номер букви poz:
            for(int i = 0; i < alphabet.length; i++){   // проходимо всі номери букв алфавіту, і
                rez[poz]=i; // записуємо поточний у масив на позицію poz
                wordRecursionGenerator(rez, alphabet,poz+1); // викликаємо генератор для наступної позиції букви
            }
        }
    }
    //################################################################################################################################################################################################
    static void writeToFile(Human[] Hm) throws IOException {  // метод, що записуватиме отриманий масив у файл
        FileWriter fw=new FileWriter("Humans.txt",false);    // створюєм об'єкт записувач у файл, передавши в конструктор ім'я файла(якщо такого фала не буде в папці проєкту, він автоматично створеться)
        fw.write(Hm.length+"\n");  // запис у перший рядок файла к-сті елементів масива
        for (int i=0;i<Hm.length;i++)   // прохід всього масива
            fw.write(Hm[i].druk()+"\n");    // і запис кожного елемента та переходу на новий рядок в файл
        fw.close(); // закриття зчитувач файла
    }
    //################################################################################################################################################################################################
    static Human[] readOfFile() throws IOException {   // метод, що зчитуватиме масив із файла
        FileReader fr = new FileReader("Humans.txt");  // створюєм об'єкт зчитувач файла, передавши в конструктор ім'я файла(файл має бути у папці проєкту)
        Scanner scf = new Scanner(fr);    // сканер для сканування рядків в файлі
        Scanner scr;    // сканер для сканування слів в рядку
        String ryadok;  // кожен рядок записуватиметься у цю змінну
        int l = 0;    // у змінну l зчитаєм к-сть елементів масива
        if (scf.hasNextInt())    // якщо далі є ціле число,
            l = scf.nextInt();    // то записуєм його в l
        else {  // якщо цілого числа нема
            System.out.println("Помилка файлу");
            return null;    // і завершуєм метод, не повернувши масив
        }
        System.out.println(l);  // друкуєм зчитану к-сть людей
        ryadok = scf.nextLine();    // скануєм решту рядка після числа, щоб перевести курсор на перший рядок з людиною
        scr = new Scanner(ryadok);  // створюєм сканер цього рядка
        Human[] Hm = new Human[l];    // створюєм масив людей такої довжини
        int id=0;
        String name = null;     // створюєм змінні для запису зчитаних значень
        String surname = null;
        int birt = 0;
        String school = null;
        int st = 0;
        int n = 0;  // номер людини що зчитується
        while (scf.hasNext()) {       // поки далі в файлі щось є
            ryadok = scf.nextLine();    // зчитуємо черговий рядок
            scr = new Scanner(ryadok);  // створюєм сканер цього рядка
            if (scr.hasNext()) {
                id= scr.nextInt();
                if (scr.hasNext()) {    // якщо першим щось є
                    name = scr.next();  // то записати його в змінну імені
                    if (scr.hasNext()) {    // якщо другим щось є
                        surname = scr.next();   // то записати його в змінну прізвища
                        if (scr.hasNextInt()) {     // якщо третім є ціле число
                            birt = scr.nextInt();   // то записати його в змінну дати народження
                            if (scr.hasNext()) {    // якщо четвертим щось є
                                school = scr.next();    // то записати його в змінну назви навчального закладу
                                if (scr.hasNextInt()) {     // якщо п'ятим є ціле число
                                    st = scr.nextInt(); // то записати його в змінну стипендії
                                    Hm[n] = new Student(id, name, surname, birt, school, st);   // якщо ми опинилися тут, то зчитали 5 полів, тому це студент, якого і створюємо
                                    n++;    // збільшуєм номер людини в масиві
                                }
                            } else {  // якщо четвертим НЕМАЄ НІЧОГО
                                Hm[n] = new Human(id, name, surname, birt); // то три значення є точно, раз ми сюди дойшли, тому це проста людина, яку і створюємо
                                n++;    // збільшуєм номер людини в масиві
                            }
                        }
                    }
                }
            }
        }
        fr.close();      // закриття об'єктів що працюють з зовнішніми ресурсами
        scr.close();
        scf.close();
        return Hm;  // повернення зчитаного з файла масива
    }
}   // дужка класу Main

